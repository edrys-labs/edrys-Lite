diff --git a/node_modules/y-webrtc/src/SimplePeerExtended.js b/node_modules/y-webrtc/src/SimplePeerExtended.js
index dbe024c..514018f 100644
--- a/node_modules/y-webrtc/src/SimplePeerExtended.js
+++ b/node_modules/y-webrtc/src/SimplePeerExtended.js
@@ -109,6 +109,11 @@ class SimplePeerExtended extends Peer {
     return a.index > b.index ? 1 : -1
   }
   send(chunk) {
+    // Don't queue messages if the peer is destroyed or disconnected
+    if (this.destroyed || !this._channel || this._channel.readyState !== 'open') {
+      return
+    }
+    
     if (chunk instanceof ArrayBuffer) chunk = new Uint8Array(chunk)
     let chunks = this.packetArray(chunk, CHUNK_SIZE)
     this.webRTCMessageQueue = this.webRTCMessageQueue.concat(chunks)
@@ -117,6 +122,14 @@ class SimplePeerExtended extends Peer {
   }
   sendMessageQueued() {
     this.webRTCPaused = false
+    
+    // Check if the peer is still connected before processing the queue
+    if (this.destroyed || !this._channel || this._channel.readyState !== 'open') {
+      // Clear the message queue if the peer is destroyed or disconnected
+      this.webRTCMessageQueue = []
+      return
+    }
+    
     let message = this.webRTCMessageQueue.shift()
     while (message) {
       if (
@@ -138,17 +151,28 @@ class SimplePeerExtended extends Peer {
       } catch (error) {
         console.warn('y-webrtc:simplepeer:sendMessageQueued', { error })
         if (error.code === 11) {// Failed to execute 'send' on 'RTCDataChannel': RTCDataChannel.readyState is not 'open'
-          //TODO: block sending until connected
+          // Clear the message queue when connection is closed to prevent infinite retries
+          this.webRTCMessageQueue = []
+          this.webRTCPaused = false
+          return
         }
         break
         //super.destroy()
       }
-      if (this.webRTCMessageQueue.length) {
-        setTimeout(this.sendMessageQueued, 200)
-      }
+    }
     
+    // Only schedule next batch if we successfully processed messages and there are more to send
+    if (this.webRTCMessageQueue.length && !this.webRTCPaused) {
+      setTimeout(() => this.sendMessageQueued(), 200)
     }
   }
+  
+  destroy() {
+    // Clear the message queue when destroying the peer
+    this.webRTCMessageQueue = []
+    this.webRTCPaused = false
+    super.destroy()
+  }
 }
 
 export default SimplePeerExtended
diff --git a/node_modules/y-webrtc/src/y-webrtc.js b/node_modules/y-webrtc/src/y-webrtc.js
index c272143..10d37cd 100644
--- a/node_modules/y-webrtc/src/y-webrtc.js
+++ b/node_modules/y-webrtc/src/y-webrtc.js
@@ -56,38 +56,51 @@ const checkIsSynced = (room) => {
 }
 
 const validMessage = async (room, data) => {
-  const decoder = decoding.createDecoder(data)
-  const messageType1 = decoding.readVarUint(decoder)
-  const messageType2 = decoding.readVarUint(decoder)
-  /*console.warn('validMessage:decode', {
-    messageType1,
-    messageType2,
-    messageSync,
-    data,
-  })*/
-  /*
-  const messageSync = 0
-  const messageQueryAwareness = 3
-  const messageAwareness = 1
-  const messageBcPeerId = 4
-  */
-  const isSync = messageType1 === messageSync &&
-    (syncProtocol.messageYjsSyncStep2 === messageType2 ||
-    syncProtocol.messageYjsUpdate === messageType2)
-  const isAwareness = messageType1 === messageAwareness
-    || messageType1 === messageQueryAwareness
-  const isBc = messageType1 === messageBcPeerId
-  const isMessage = isSync || isAwareness || isBc
-  let valid = false
   try {
-    valid = await room.validateUpdate(
-      { decoded: decoding.readVarUint8Array(decoder), raw: data, isMessage }
-    )
+    const decoder = decoding.createDecoder(data)
+    const messageType1 = decoding.readVarUint(decoder)
+    const messageType2 = decoding.readVarUint(decoder)
+    /*console.warn('validMessage:decode', {
+      messageType1,
+      messageType2,
+      messageSync,
+      data,
+    })*/
+    /*
+    const messageSync = 0
+    const messageQueryAwareness = 3
+    const messageAwareness = 1
+    const messageBcPeerId = 4
+    */
+    const isSync = messageType1 === messageSync &&
+      (syncProtocol.messageYjsSyncStep2 === messageType2 ||
+      syncProtocol.messageYjsUpdate === messageType2)
+    const isAwareness = messageType1 === messageAwareness
+      || messageType1 === messageQueryAwareness
+    const isBc = messageType1 === messageBcPeerId
+    const isMessage = isSync || isAwareness || isBc
+    
+    if (!isMessage) {
+      // If it's not a recognized y-webrtc message type, it might be a chunk
+      // Allow chunks to pass through without validation
+      return true
+    }
+    
+    let valid = false
+    try {
+      valid = await room.validateUpdate(
+        { decoded: decoding.readVarUint8Array(decoder), raw: data, isMessage }
+      )
+    } catch (e) {
+      console.warn('!InvalidDataFromUpdate', { e, room, data })
+      return false
+    }
+    return valid
   } catch (e) {
-    console.warn('!InvalidDataFromUpdate', { e, room, data })
-    return false
+    // If decoding fails (e.g., due to chunks), allow the data through
+    // This prevents chunked messages from being rejected
+    return true
   }
-  return valid
 }
 
 /**
